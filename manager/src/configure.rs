use crate::{
    cloudflare::{Cloudflare, CloudflareDomainFallback, CloudflareInclude},
    config::Config,
    service::Service,
};
use local_ip_address::linux::local_ip;

const VIRTUAL_NETWORK_NAME: &str = "homelab";

pub fn configure(services: &Vec<Service>) {
    let config = match Config::open() {
        Some(config) => config,
        None => panic!("The project must be bootstrapped before configuring"),
    };

    let account = config.cloudflare.account.unwrap();
    let tunnel = config.cloudflare.tunnel.unwrap();

    let cloudflare = Cloudflare::new(
        config.cloudflare.user.api_token.clone().unwrap(),
        config.cloudflare.user.email.clone().unwrap(),
    );

    let virtual_networks = cloudflare.list_virtual_networks(&account.id);
    let has_default_virtual_network = virtual_networks
        .iter()
        .any(|network| !network.deleted && network.default);
    let virtual_network = virtual_networks
        .iter()
        .find(|network| !network.deleted && network.name == VIRTUAL_NETWORK_NAME)
        .map_or_else(
            || {
                println!("Couldn't find virtual network. Creating one.");

                cloudflare.create_virtual_network(
                    &account.id,
                    VIRTUAL_NETWORK_NAME,
                    Some("[AUTOGENERATED] Virtual network utilized by the homelab".to_string()),
                    !has_default_virtual_network,
                )
            },
            Clone::clone,
        );

    println!(
        "Using virtual network {} ({})",
        virtual_network.name, virtual_network.id
    );

    let local_ip = local_ip().unwrap();
    let ip_mask = format!("{}/32", local_ip);
    println!("Using local IP: {}", ip_mask);

    cloudflare.create_tunnel_route(
        &account.id,
        tunnel.id,
        &virtual_network.id,
        &ip_mask,
        Some("[AUTOGENERATED] Homelab host machine".to_string()),
    );

    println!("Created tunnel route");

    cloudflare.enable_gateway_proxy(&account.id);

    println!("Enabled gateway proxy");

    let mut domains = cloudflare.list_fallback_domains(&account.id);
    let mut includes = cloudflare.list_split_tunnel_includes(&account.id);
    for service in services {
        if let Some(domain_name) = &service.domain {
            if domains.iter().any(|domain| &domain.suffix == domain_name) {
                println!("Domain {} already exists, skipping", domain_name);
            } else {
                let domain = CloudflareDomainFallback {
                    description: Some("[AUTOGENERATED] Homelab service".to_string()),
                    dns_server: vec![format!("{}", local_ip)],
                    suffix: domain_name.clone(),
                };

                domains.push(domain);

                println!("Created DNS fallback for {} in Cloudflare", domain_name);
            }

            if includes.iter().any(|include| match &include.host {
                Some(host) => host == domain_name,
                None => false,
            }) {
                println!(
                    "Domain include for {} already exists, skipping",
                    domain_name
                );
            } else {
                let include = CloudflareInclude {
                    address: None,
                    description: Some("[AUTOGENERATED] Homelab service".to_string()),
                    host: Some(domain_name.clone()),
                };

                includes.push(include);

                println!(
                    "Created split tunnel include for {} in Cloudflare",
                    domain_name
                );
            }
        }
    }

    cloudflare.set_fallback_domains(&account.id, domains);

    println!("Successfully set fallback domains");

    if !includes.iter().any(|include| match &include.address {
        Some(address) => address == &ip_mask,
        None => false,
    }) {
        includes.push(CloudflareInclude {
            address: Some(ip_mask),
            description: Some("[AUTOGENERATED] Homelab host".to_string()),
            host: None,
        });

        println!("Created split tunnel include for base IP");
    } else {
        println!("Split tunnel include for base IP found, skipping");
    }

    cloudflare.set_split_tunnel_includes(&account.id, includes);

    println!("Successfully set split tunnel includes");
}
