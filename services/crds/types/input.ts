// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import * as utilities from "../utilities";

import {ObjectMeta} from "../meta/v1";

export namespace metallb {
    export namespace v1beta1 {
        /**
         * IPAddressPoolSpec defines the desired state of IPAddressPool.
         */
        export interface IPAddressPoolSpecArgs {
            /**
             * A list of IP address ranges over which MetalLB has authority.
             * You can list multiple ranges in a single pool, they will all share the
             * same settings. Each range can be either a CIDR prefix, or an explicit
             * start-end range of IPs.
             */
            addresses: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * AutoAssign flag used to prevent MetallB from automatic allocation
             * for a pool.
             */
            autoAssign?: pulumi.Input<boolean>;
            /**
             * AvoidBuggyIPs prevents addresses ending with .0 and .255
             * to be used by a pool.
             */
            avoidBuggyIPs?: pulumi.Input<boolean>;
            /**
             * AllocateTo makes ip pool allocation to specific namespace and/or service.
             * The controller will use the pool with lowest value of priority in case of
             * multiple matches. A pool with no priority set will be used only if the
             * pools with priority can't be used. If multiple matching IPAddressPools are
             * available it will check for the availability of IPs sorting the matching
             * IPAddressPools by priority, starting from the highest to the lowest. If
             * multiple IPAddressPools have the same priority, choice will be random.
             */
            serviceAllocation?: pulumi.Input<inputs.metallb.v1beta1.IPAddressPoolSpecServiceAllocationArgs>;
        }
        /**
         * ipaddressPoolSpecArgsProvideDefaults sets the appropriate defaults for IPAddressPoolSpecArgs
         */
        export function ipaddressPoolSpecArgsProvideDefaults(val: IPAddressPoolSpecArgs): IPAddressPoolSpecArgs {
            return {
                ...val,
                autoAssign: (val.autoAssign) ?? true,
                avoidBuggyIPs: (val.avoidBuggyIPs) ?? false,
            };
        }

        /**
         * AllocateTo makes ip pool allocation to specific namespace and/or service.
         * The controller will use the pool with lowest value of priority in case of
         * multiple matches. A pool with no priority set will be used only if the
         * pools with priority can't be used. If multiple matching IPAddressPools are
         * available it will check for the availability of IPs sorting the matching
         * IPAddressPools by priority, starting from the highest to the lowest. If
         * multiple IPAddressPools have the same priority, choice will be random.
         */
        export interface IPAddressPoolSpecServiceAllocationArgs {
            /**
             * NamespaceSelectors list of label selectors to select namespace(s) for ip pool,
             * an alternative to using namespace list.
             */
            namespaceSelectors?: pulumi.Input<pulumi.Input<inputs.metallb.v1beta1.IPAddressPoolSpecServiceAllocationNamespaceSelectorsArgs>[]>;
            /**
             * Namespaces list of namespace(s) on which ip pool can be attached.
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Priority priority given for ip pool while ip allocation on a service.
             */
            priority?: pulumi.Input<number>;
            /**
             * ServiceSelectors list of label selector to select service(s) for which ip pool
             * can be used for ip allocation.
             */
            serviceSelectors?: pulumi.Input<pulumi.Input<inputs.metallb.v1beta1.IPAddressPoolSpecServiceAllocationServiceSelectorsArgs>[]>;
        }

        /**
         * A label selector is a label query over a set of resources. The result of matchLabels and
         * matchExpressions are ANDed. An empty label selector matches all objects. A null
         * label selector matches no objects.
         */
        export interface IPAddressPoolSpecServiceAllocationNamespaceSelectorsArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.metallb.v1beta1.IPAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface IPAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector is a label query over a set of resources. The result of matchLabels and
         * matchExpressions are ANDed. An empty label selector matches all objects. A null
         * label selector matches no objects.
         */
        export interface IPAddressPoolSpecServiceAllocationServiceSelectorsArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.metallb.v1beta1.IPAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface IPAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * L2AdvertisementSpec defines the desired state of L2Advertisement.
         */
        export interface L2AdvertisementSpecArgs {
            /**
             * A list of interfaces to announce from. The LB IP will be announced only from these interfaces.
             * If the field is not set, we advertise from all the interfaces on the host.
             */
            interfaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A selector for the IPAddressPools which would get advertised via this advertisement.
             * If no IPAddressPool is selected by this or by the list, the advertisement is applied to all the IPAddressPools.
             */
            ipAddressPoolSelectors?: pulumi.Input<pulumi.Input<inputs.metallb.v1beta1.L2AdvertisementSpecIpAddressPoolSelectorsArgs>[]>;
            /**
             * The list of IPAddressPools to advertise via this advertisement, selected by name.
             */
            ipAddressPools?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * NodeSelectors allows to limit the nodes to announce as next hops for the LoadBalancer IP. When empty, all the nodes having  are announced as next hops.
             */
            nodeSelectors?: pulumi.Input<pulumi.Input<inputs.metallb.v1beta1.L2AdvertisementSpecNodeSelectorsArgs>[]>;
        }

        /**
         * A label selector is a label query over a set of resources. The result of matchLabels and
         * matchExpressions are ANDed. An empty label selector matches all objects. A null
         * label selector matches no objects.
         */
        export interface L2AdvertisementSpecIpAddressPoolSelectorsArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.metallb.v1beta1.L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface L2AdvertisementSpecIpAddressPoolSelectorsMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector is a label query over a set of resources. The result of matchLabels and
         * matchExpressions are ANDed. An empty label selector matches all objects. A null
         * label selector matches no objects.
         */
        export interface L2AdvertisementSpecNodeSelectorsArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.metallb.v1beta1.L2AdvertisementSpecNodeSelectorsMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface L2AdvertisementSpecNodeSelectorsMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

    }
}
